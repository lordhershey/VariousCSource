/*******************************************************************
**     C O L L E C T I O N    R E S O U R C E    S Y S T E M      **
********************************************************************
**                                                                **
** (C)opyright 1985-2014 by CR Software, LLC - All Rights Reserved**
**                                                                **
********************************************************************/

#include "crs_h/fileids.h"
CRS_FILE_ID("(C) CRS $Id: MyCommonCode.c 50858 2014-10-02 19:47:52Z UweJacobs $ $URL: https://svnserver.fairisaac.com:8443/svn/CRSW/crs4/trunk/modules/predial/tcnsort/MyCommonCode.c $");
CRS_FILE_IDENT("CCA Dynamic Monitoring Common Code");

#include <unistd.h>

#ifdef __linux__
#  include <getopt.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>   /* umask */
#include <ctype.h>      /* isalnum, isdigit */
#include <stdarg.h>
#include <string.h>

#include "crs.h"
#include "tokens.h"
#include "special.h"
#include "extend.h"
#include "fixedfee.h"
#include "other.h"
#include "strategy.h"
#include "medical.h"
#include "kkEnum.h"

#define MY_COMMON_CODE_PROTO

#include "MyCommonCode.h"

#include "prototypes/MyCommonCode.h"

static int UpcaseTokens = 1;

/* *INDENT-OFF*
   ############################################################
   #                       Screen Templates                   #
   ############################################################
   *INDENT-ON* */



/*!
  \brief This draws a basic blank screen with lines at 400 and 1600

  \return 0
 */
int drawBasicScreen(void)
{
    scrinit();
    clearScreen();
    printDashedLines();
    return (0);
}

/*!
  \brief Clears the screen except for the horizonal bars at 400 and 1600
 
  \return 0
 */
int clearScreen(void)
{
    print_at(80);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);

    print_at(480);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s\n", CE);

    print_at(1680);
    printf("%s\n", CE);
    printf("%s\n", CE);
    printf("%s", CE);

    return (0);
}

/*!
  \brief Prints horrizontal bars at 400 and 1600
 
  \return 0
 */
int printDashedLines(void)
{
    print_at(400);
    printf("%s%s%s%s%s", C1, G_START, LINE, G_END, C0);
    print_at(1600);
    printf("%s%s%s%s%s", C1, G_START, LINE, G_END, C0);
    print_at(480);
    return (0);
}

/*!
  \brief prints the screen title

  \param line the line we wish to print the title on
  \param fmt used like printf
  \return 0
 */
int titlef(int line, char *fmt, ...)
{
    char title[500];
    va_list args;

    memset(title, '\0', sizeof(title));

    va_start(args, fmt);
    vsprintf(title, fmt, args);
    va_end(args);

    screen_title(title, line);

    return (0);
}

/* *INDENT-OFF*
   ############################################################
   #              Input Options and Validation                #
   ############################################################
   *INDENT-ON* */
/*!
  \brief trim the spaces and null characters from a byte
  sequence replacing them with just spaces.
  
  \param[in] s the character buffer
  \param[in] z the size of the buffer
  \return 0 if ok, -1 if s is NULL or sz < 1
 */
int trimSpaceAndZeroFromEnd(char *s, int sz)
{
    int i;

    if (s == NULL || sz < 1)
    {
        return -1;
    }

    for (i = (sz - 1); i > -1; i--)
    {
        if (s[i] == '\0' || s[i] == ' ' || s[i] == '\n' || s[i] == '\r')
        {
            s[i] = '\0';
            continue;
        }
        break;
    }

    return 0;
}

/*!
  \brief clean out the white space from the front and back

  \param[in] s the string to clean
  \param[in] sz the size of the buffer
  \retval 0 success
  \retval -1 failure
 */
int trimSpaceAndZeroFromBeginToEnd(char *s, int sz)
{
    int i, j;

    if (NULL == s || sz < 1)
    {
        return (-1);
    }

    /*cut off white space on front */
    for (i = 0; i < (sz - 1) &&
         ('\0' == s[0] ||
          ' ' == s[0] || '\n' == s[0] || '\r' == s[0] || '\t' == s[0]); i++)
    {
        for (j = 1; j < sz; j++)
        {
            s[(j - 1)] = s[j];
            s[j] = ' ';
        }
    }
    return (trimSpaceAndZeroFromEnd(s, sz));
}

/*!
  \brief tells us if the loop is on the given page

  \param[in] page_no the page we are on
  \param[in] loop the position we are in the big loop
  \retval 0 not on same page
  \retval 1 on same page
 */
int _same_page_wc(int page_no, int loop)
{
    int l_page = loop / 14;

    if (page_no == l_page)
    {
        return (1);
    }

    return (0);
}

/*!
  \brief give the position of this loop position

  \param[in] x the position of the loop we are in
  \return the line this case is on.
 */
int _case_pos(int x)
{
    int a = (x % 14) + 6;

    a = a * 80;
    return (a);
}

/*!
  \brief copy a CSV token to a fixed size buffer

  \param[out] fld the target character field
  \param[in] size the size of fld
  \param[in] src a null terminated string
  \return the size of the string
  \retval -1 some issue with fld or size of fld
 */
int setCharField(char *fld, int size, const char *src)
{
    if (NULL == fld || size < 1)
    {
        return (-1);
    }

    memset(fld, '\0', size);

    if ((NULL == src) || (strlen(src) < 1))
    {
        return (1);
    }

    snprintf(fld, size, "%s", src);

    return (strlen(fld));
}

/*!
  \brief checks to see if the given action code exists

  \param[in] resultCode the 2 char action code
  \param[in] mustExist a flag stating whether checkin a blank
  code is valid or not
  \retval 1 code is blank (mustExist is 0)
  \retval 0 code exists
  \retval -1 code does not exist
 */
int validActionCode(char *actionCode, int mustExist)
{

    int y;

    if (memcmp(actionCode, "  ", 2) == 0)
    {
        if (mustExist)
        {
            return (-1);
        }

        /*it is blank */
        return (1);
    }

    actionCode[0] = toupper(actionCode[0]);

    actionCode[1] = toupper(actionCode[1]);

    for (y = 0; actionCode[0] != a_code_table[y * 2]
         || actionCode[1] != a_code_table[(y * 2) + 1]; y++)
    {
        if (y > MAX_AR_CODE_VALUE)
            break;
    }

    if (y > MAX_AR_CODE_VALUE)
    {
        return (-1);
    }

    return (0);
}

/*!
  \brief Gets the integer code of a action code

  \param[in] resultCodeactionCode a 2 char code
  \retval -1 not found/ code blank
  \return the integer code for the action 
*/
int getActionCode(char *actionCode)
{

    int y;

    if (memcmp(actionCode, "  ", 2) == 0)
    {
        /*it is blank */
        return (-1);
    }

    actionCode[0] = toupper(actionCode[0]);

    actionCode[1] = toupper(actionCode[1]);

    for (y = 0; actionCode[0] != a_code_table[y * 2]
         || actionCode[1] != a_code_table[(y * 2) + 1]; y++)
    {
        if (y > MAX_AR_CODE_VALUE)
            break;
    }

    if (y > MAX_AR_CODE_VALUE)
    {
        return (-1);
    }

    return (y + 1);
}

/*!
  \brief checks to see if the given result code exists

  \param[in] resultCode the 2 char result code
  \param[in] mustExist a flag stating whether checkin a blank
  code is valid or not
  \retval 1 code is blank (mustExist is 0)
  \retval 0 code exists
  \retval -1 code does not exist
 */
int validResultCode(char *resultCode, int mustExist)
{

    int y;

    if (memcmp(resultCode, "  ", 2) == 0)
    {
        if (mustExist)
        {
            return (-1);
        }

        /*it is blank */
        return (1);
    }

    resultCode[0] = toupper(resultCode[0]);
    resultCode[1] = toupper(resultCode[1]);

    for (y = 0; resultCode[0] != r_code_table[y * 2]
         || resultCode[1] != r_code_table[(y * 2) + 1]; y++)
    {
        if (y > MAX_AR_CODE_VALUE)
            break;
    }

    if (y > MAX_AR_CODE_VALUE)
    {
        return (-1);
    }

    return (0);
}

/*!
  \brief Gets the integer code of a result code

  \param[in] resultCode a 2 char code
  \retval -1 not found/ code blank
  \return the integer code for the result 
*/
int getResultCode(char *resultCode)
{

    int y;

    if (memcmp(resultCode, "  ", 2) == 0)
    {
        return (-1);
    }

    resultCode[0] = toupper(resultCode[0]);
    resultCode[1] = toupper(resultCode[1]);

    for (y = 0; resultCode[0] != r_code_table[y * 2]
         || resultCode[1] != r_code_table[(y * 2) + 1]; y++)
    {
        if (y > MAX_AR_CODE_VALUE)
            break;
    }

    if (y > MAX_AR_CODE_VALUE)
    {
        return (-1);
    }

    return (y + 1);
}

/*!
  \brief fill the storage option

  \param[out] pfield the field to store the value in
  \param[in] loc
  \param[in] display flag if set to 1 we print the value with Description if any
  \param[in] hp home phone flag
  \param[in] wp work phone flag
  \param[in] mp mobile phone flag
  \param[in] op store to other page
  \param[in] pd store to phone databse
  \param[in] bs behavior score flag
  \param[in] auxe use aux fields e
  \param[in[ auxa use aux fields a
  \param[in] auxe use aux fields m
  \param[in[ auxa use aux fields d
  \param[in] bk bank account from fincancial 
  \param[in] an detail account number
  \param[in] tr transactions
  \param[in] dl detail date last
  \param[in] ct
  \param[in] st
  \param[in] zp
  \param[in] em
  \param[in] a1
  \param[in] a2
  \param[in] ss   
  \param[in] fn   
  \param[in] ln   
  \param[in] lf 
*/
int getStorageOption(char *pfield,
                     int loc,
                     int display,
                     int hp,
                     int wp,
                     int mp,
                     int op,
                     int pd,
                     int bs,
                     int auxe,
                     int auxa,
                     int auxp,
                     int auxm, int auxd, int bk, int an, int tr, int dl,
                     int ct,
                     int st,
                     int zp,
                     int em, int a1, int a2, int ss, int fn, int ln, int lf)
{
    char field[10];
    char displayf[80];
    int fieldnumber = 0;
    char storeFields[100][50];
    int lenStore = 0;
    int i;

    /*blank out use of aud flags if no aux 1 */
    if (!AUX1_FLAG)
    {
        auxe = 0;
        auxa = 0;
    }

    if (display)
    {
        if (0 == pfield[0] ||
            memcmp(pfield, "  ", 2) == 0 || memcmp(pfield, "NU", 2) == 0)
        {
            /*Not Used / Not Stored */
            printf("NU Not Used");
        }
        else if (memcmp(pfield, "HP", 2) == 0)
        {
            /*Home Phone */
            printf("HP Home Phone");
        }
        else if (memcmp(pfield, "WP", 2) == 0)
        {
            /*Work Phone */
            printf("WP Work Phone");
        }
        else if (memcmp(pfield, "MP", 2) == 0)
        {
            /*Mobile Phone */
            printf("MP Mobile Phone");
        }
        else if (memcmp(pfield, "OP", 2) == 0)
        {
            /*Other Page */
            printf("OP Other Page");
        }
        else if (memcmp(pfield, "PD", 2) == 0)
        {
            /*Phone Database */
            printf("PD Phone Database");
        }
        else if (memcmp(pfield, "BS", 2) == 0)
        {
            /*Behavior Score */
            printf("BS Behavior Score");
        }
        else if (memcmp(pfield, "BK", 2) == 0)
        {
            /*Bank Account Number */
            printf("BK Banking Info");
        }
        else if (memcmp(pfield, "AN", 2) == 0)
        {
            /*Detail Account Number */
            printf("AN Detail Acct #");
        }
        else if (memcmp(pfield, "TR", 2) == 0)
        {
            printf("TR Transactions");
        }
        else if (memcmp(pfield, "DL", 2) == 0)
        {
            /*Detail Account Number */
            printf("DL Acct Date Lst");
        }
        else if (memcmp(pfield, "CT", 2) == 0)
        {
            /*Detail Account Number */
            printf("CT City         ");
        }
        else if (memcmp(pfield, "ST", 2) == 0)
        {
            /*Detail Account Number */
            printf("ST State/Prov   ");
        }
        else if (memcmp(pfield, "ZP", 2) == 0)
        {
            /*Detail Account Number */
            printf("ZP Zip Code     ");
        }
        else if (memcmp(pfield, "EM", 2) == 0)
        {
            /*Detail Account Number */
            printf("EM Employer     ");
        }
        else if (memcmp(pfield, "A1", 2) == 0)
        {
            /*Detail Account Number */
            printf("A1 Address Ln 1 ");
        }
        else if (memcmp(pfield, "A2", 2) == 0)
        {
            /*Detail Account Number */
            printf("A1 Address Ln 2 ");
        }
        else if (memcmp(pfield, "SS", 2) == 0)
        {
            /*Detail Account Number */
            printf("SS SSN/EIN      ");
        }
        else if (memcmp(pfield, "FN", 2) == 0)
        {
            /*master first */
            printf("FN First Name   ");
        }
        else if (memcmp(pfield, "LN", 2) == 0)
        {
            /*master last */
            printf("LN Last Name    ");
        }
        else if (memcmp(pfield, "LF", 2) == 0)
        {
            /*master last first */
            printf("LF Last,First   ");
        }
        else
        {
             /**/ if (!AUX1_FLAG)
            {
                printf("%2.2s Unknown", pfield);
                return (0);
            }
            memset(field, '\0', sizeof(field));
            snprintf(field, sizeof(field), "%2.2s", pfield);
            fieldnumber = atoi(field);
            if (fieldnumber < 0 || fieldnumber >= aux1_rec.num_label)
            {
                printf("%2.2s Out of Range", pfield);
                return (0);
            }
            snprintf(displayf, sizeof(displayf),
                     "%2d %12.12s", fieldnumber,
                     aux1_rec.label[fieldnumber].label);
            printf(displayf);
        }

        return (0);
    }

    lenStore = 0;

    for (i = 0; i < 100; i++)
    {
        memset((char *)&storeFields[i][0], '\0', 50);
    }

    snprintf(&storeFields[lenStore][0], 50, "NU\bNot Used");
    lenStore++;

    if (hp)
    {
        snprintf(&storeFields[lenStore][0], 50, "HP\bHome Phone");
        lenStore++;
    }

    if (wp)
    {
        snprintf(&storeFields[lenStore][0], 50, "WP\bWork Phone");
        lenStore++;
    }

    if (mp)
    {
        snprintf(&storeFields[lenStore][0], 50, "MP\bMobile Phone");
        lenStore++;
    }

    if (op)
    {
        snprintf(&storeFields[lenStore][0], 50, "OP\bOther Page");
        lenStore++;
    }

    if (pd)
    {
        snprintf(&storeFields[lenStore][0], 50, "PD\bPhone Database");
        lenStore++;
    }

    if (bs)
    {
        snprintf(&storeFields[lenStore][0], 50, "BS\bBehavior Score");
        lenStore++;
    }

    if (bk)
    {
        snprintf(&storeFields[lenStore][0], 50, "BK\bBanking Info");
        lenStore++;
    }

    if (an)
    {
        snprintf(&storeFields[lenStore][0], 50, "AN\bDetail Acct #");
        lenStore++;
    }

    if (tr)
    {
        snprintf(&storeFields[lenStore][0], 50, "TR\bTransactions");
        lenStore++;
    }

    if (dl)
    {
        snprintf(&storeFields[lenStore][0], 50, "DL\bDate Last   ");
        lenStore++;
    }

    if (ct)
    {
        snprintf(&storeFields[lenStore][0], 50, "CT\bCity        ");
        lenStore++;
    }

    if (st)
    {
        snprintf(&storeFields[lenStore][0], 50, "ST\bState/Prov  ");
        lenStore++;
    }

    if (zp)
    {
        snprintf(&storeFields[lenStore][0], 50, "ZP\bZip/Postal  ");
        lenStore++;
    }

    if (em)
    {
        snprintf(&storeFields[lenStore][0], 50, "EM\bEmployer    ");
        lenStore++;
    }

    if (a1)
    {
        snprintf(&storeFields[lenStore][0], 50, "A1\bAddress L1  ");
        lenStore++;
    }

    if (a2)
    {
        snprintf(&storeFields[lenStore][0], 50, "A2\bAddress L2  ");
        lenStore++;
    }

    if (ss)
    {
        snprintf(&storeFields[lenStore][0], 50, "SS\bSSN/EIN     ");
        lenStore++;
    }

    if (fn)
    {
        snprintf(&storeFields[lenStore][0], 50, "FN\bFirst Name  ");
        lenStore++;
    }

    if (ln)
    {
        snprintf(&storeFields[lenStore][0], 50, "LN\bLast Name   ");
        lenStore++;
    }

    if (lf)
    {
        snprintf(&storeFields[lenStore][0], 50, "LF\bLast,First  ");
        lenStore++;
    }

    if (AUX1_FLAG)
    {

        for (i = 0; (i < aux1_rec.num_label) && (lenStore < 50); i++)
        {
            if (('E' == aux1_rec.label[i].lab_type && auxe) ||
                ('A' == aux1_rec.label[i].lab_type && auxa) ||
                ('P' == aux1_rec.label[i].lab_type && auxp) ||
                ('M' == aux1_rec.label[i].lab_type && auxm) ||
                ('D' == aux1_rec.label[i].lab_type && auxd))
            {
                snprintf(&storeFields[lenStore][0], 50, "%2d\b%12.12s",
                         i, aux1_rec.label[i].label);
                lenStore++;
            }
        }
    }

    return getStringFieldFromArray(loc, 2, pfield, 1, 0, storeFields);
}

/*!                                                                                               
  \brief present a tab option for a char buffer

  \param[in] loc the location to get the buffer at
  \param[in] len the length of the buffer
  \param[in] f the buffer to fill
  \param[in] allowInvalid will let the use put in a sequence that is
  not defined in the list
  \param[in] displayOnly will print out the value of the text field
  and then exit the routine with 0 if set to 1
  \param[in] array the strings values plus the description the first
  len characters is the value and the rest of it is the values
  \retun the value that got us out of this routine
  \retval 0 if displayOnly is set to 1 or ENTER_KEY pressed
 */
int getStringFieldFromArray(int loc,
                            int len,
                            char *f,
                            int allowInvalid,
                            int displayOnly, char array[50][50])
{
    int max = 0;

    int x, i;

    char **list = NULL;

    char inchar[80];

    int ret = 0;

    int found = -1;

    unsigned int longest = 0;

    char printBuffer[81];

    for (max = 0, i = 0; i < 50 && strlen(array[i]) > 0; i++)
    {
        if (strlen(array[i]) < len)
        {
            continue;
        }
        max++;
    }

    list = (char **)malloc(sizeof(char *) * max);
    for (i = 0, x = 0, longest = 0; (strlen(array[i]) > 0) && (i < 50); i++)
    {
        list[x] = array[i];

        if (memcmp(list[x], f, len) == 0)
        {
            found = x;
        }
        if (strlen(list[x]) > longest)
        {
            longest = strlen(list[x]);
        }

        x++;
    }

    if (found < 0 && !allowInvalid)
    {
        memcpy(f, list[0], 3);
        found = 0;
    }

    if (found > -1 && found < max)
    {
        print_at(loc);
        printf("%*.*s", len, len, list[found]);
        if (strlen(list[found]) > len)
        {
            memset(printBuffer, ' ', sizeof(printBuffer));
            printBuffer[80] = '\0';
            snprintf(printBuffer, longest, "%s%s%s%s%s",
                     &list[found][len],
                     "                    ",
                     "                    ",
                     "                    ", "                    ");
        }
        else
        {
            snprintf(printBuffer, longest, "%s%s%s%s",
                     "                    ",
                     "                    ",
                     "                    ", "                    ");
        }
        printf(" %*s", longest, printBuffer);
    }

    if (displayOnly)
    {
        return (0);
    }

    memcpy(inchar, f, len);

    for (;;)
    {
        ret = data_input(inchar, len, loc, AUTO_RETURN, 0);

        if (F1_KEY == ret)
        {
            if (max > 0)
            {
                free(list);
                list = NULL;
            }
            return (F1_KEY);
        }

        /*Find the char */
        for (x = 0, i = -1; x < max && max > 0; x++)
        {
            if (memcmp(inchar, list[x], len) == 0)
            {
                i = x;
                break;
            }
        }

        if (TAB_KEY == ret)
        {
            if (max < 1)
            {
                continue;
            }

            if (i < 0)
            {
                i = 0;
            }
            else
            {
                i = (i + 1) % max;
            }

        }

        if (i < 0 && max > 0 && !allowInvalid)
        {
            l_error("Invalid Selection - Use Tab Key to Cycle");

            memcpy(inchar, f, len);

            /*Find the char */
            for (x = 0, i = -1; x < max && max > 0; x++)
            {
                if (memcmp(inchar, list[x], len) == 0)
                {
                    i = x;
                    break;
                }
            }

            ret = TAB_KEY;
        }

        if (max > 0 && i > -1 && i < max)
        {
            memcpy(inchar, list[i], len);
            print_at(loc);
            printf("%*.*s", len, len, list[i]);
            if (strlen(list[i]) > len)
            {
                memset(printBuffer, ' ', sizeof(printBuffer));
                printBuffer[80] = '\0';
                snprintf(printBuffer, longest, "%s%s%s%s%s",
                         &list[i][len],
                         "                    ",
                         "                    ",
                         "                    ", "                    ");
            }
            else
            {
                snprintf(printBuffer, longest, "%s%s%s%s",
                         "                    ",
                         "                    ",
                         "                    ", "                    ");
            }
            printf(" %*s", longest, printBuffer);
        }

        if (TAB_KEY == ret)
        {
            continue;
        }

        memcpy(f, inchar, len);

        break;
    }

    if (max > 0)
    {
        free(list);
        list = NULL;
    }

    return (ret);
}

/* *INDENT-OFF*
   ############################################################
   #                Parsing and Data Handling                 #
   ############################################################
   *INDENT-ON* */

/*!
  \brief shoves a character onto an expanding array

  \param[out] head pointer to a pointer
  \param[in] inChar the character we wish to save
  \retval the length of queue
*/
int enqueueCharacter(struct CHARACTER_QUEUE **head, char inChar)
{
    struct CHARACTER_QUEUE *tmp = NULL;
    int block = 0;

    if (NULL == *head)
    {
        tmp = (struct CHARACTER_QUEUE *)malloc(sizeof(struct CHARACTER_QUEUE));
        memset((char *)tmp, '\0', sizeof(struct CHARACTER_QUEUE));
        tmp->len = 0;
        tmp->next = NULL;
        *head = tmp;
    }

    tmp = *head;

    while (tmp->next != NULL)
    {
        tmp = tmp->next;
        block++;
    }

    if (tmp->len > (CHARACTER_QUEUE_BUFFER_SIZE - 1))
    {
        /*we need a new block */
        tmp->next = (struct CHARACTER_QUEUE *)
                            malloc(sizeof(struct CHARACTER_QUEUE));
        memset((char *)tmp->next, '\0', sizeof(struct CHARACTER_QUEUE));
        tmp->next->len = 0;
        tmp->next->next = NULL;
        tmp = tmp->next;
        block++;
    }

    tmp->buffer[tmp->len++] = inChar;

    return (block * CHARACTER_QUEUE_BUFFER_SIZE + tmp->len);
}

/*!
  \brief dump the queue to a string

  \param[in] str is a string that is at least size + 1 of the characters
  in the character queue, it is up to the caller to make sure this is the
  case
  \param[in] head a point to a character queue
  \retval the total number of characters copied
 */
int dumpCharQueueToStr(char *str, struct CHARACTER_QUEUE *head)
{
    char *ptr = NULL;
    struct CHARACTER_QUEUE *tmp = NULL;
    int total = 0;

    tmp = head;
    ptr = str;

    while (tmp != NULL)
    {
        /*Take it on faith that the len is 1.. CHARACTER_QUEUE_BUFFER_SIZE */
        memcpy(ptr, tmp->buffer, tmp->len);
        total += tmp->len;
        /*Advance Pointer */
        ptr += tmp->len;
        tmp = tmp->next;
    }

    return (total);
}

/*!
  \brief frees the character queue

  \param[in] head pointer to a pointer
  \return the number of nodes freed
 */
int freeCharacterQueue(struct CHARACTER_QUEUE **head)
{
    struct CHARACTER_QUEUE *tmp = NULL;
    int ret = 0;

    if (NULL == *head)
    {
        return (0);
    }

    tmp = *head;
    ret = 1 + freeCharacterQueue(&tmp->next);

    free(*head);

    *head = NULL;
    return (ret);
}

/*!
  \brief put a parsed token into the token queue

  \param[out] head pointer to a pointer this is the queue
  that is modified when tokens are pushed to it
  \param[in] token a charactwer string to save t othe Queue
  \return the number of token in the queue
 */
int enqueueToken(struct TOKEN_QUEUE **head, char *token)
{
    struct TOKEN_QUEUE *tmp = NULL;
    int block = 0;

    if (NULL == *head)
    {
        tmp = (struct TOKEN_QUEUE *)malloc(sizeof(struct TOKEN_QUEUE));
        memset((char *)tmp, '\0', sizeof(struct TOKEN_QUEUE));
        tmp->len = 0;
        tmp->next = NULL;
        *head = tmp;
    }

    tmp = *head;

    while (tmp->next != NULL)
    {
        tmp = tmp->next;
        block++;
    }

    if (tmp->len > (TOKEN_QUEUE_BUFFER_SIZE - 1))
    {
        /*we need a new block */
        tmp->next = (struct TOKEN_QUEUE *)malloc(sizeof(struct TOKEN_QUEUE));
        memset((char *)tmp->next, '\0', sizeof(struct TOKEN_QUEUE));
        tmp->next->len = 0;
        tmp->next->next = NULL;
        tmp = tmp->next;
        block++;
    }

    if (NULL != token && strlen(token) > 0)
    {
        tmp->token[tmp->len] =
                            (char *)malloc(sizeof(char) * (strlen(token) + 1));
        memset(tmp->token[tmp->len], '\0', strlen(token) + 1);
        memcpy(tmp->token[tmp->len], token, strlen(token));
    }
    else
    {
        /*0 Length String */
        tmp->token[tmp->len] = (char *)malloc(sizeof(char) * 1);
        tmp->token[tmp->len][0] = '\0';
    }

    /*increase Number of Tokens */
    tmp->len++;

    return (block * TOKEN_QUEUE_BUFFER_SIZE + tmp->len);
}

/*!
  \brief Get the Token at position i starting from 0
  
  \param[in] head pointer to the token Queue
  \param[in] tokenNumber starting from position 0 get this given 
  token number
  \retval NULL tokenNumber Less than 0, head is NULL, or tokenNumber 
  out of range
  \return a valid character pointer to a NULL Terminated String
*/
char *getTokenNumber(struct TOKEN_QUEUE *head, int tokenNumber)
{
    struct TOKEN_QUEUE *tmp = NULL;
    int counter = 0;

    if (tokenNumber < 0)
    {
        return (NULL);
    }

    if (NULL == head)
    {
        return (NULL);
    }

    tmp = head;

    while (NULL != tmp)
    {
        if (counter >= tmp->len)
        {
            counter = 0;
            tmp = tmp->next;
            continue;
        }

        if (tokenNumber < 1)
        {
            return (tmp->token[counter]);
        }

        counter++;
        tokenNumber--;
    }

    return (NULL);
}

/*!
  \brief this routine will free a token queue

  \param[in] head pointer to a pointer of token queue, each
  time will be freed and set to NULL or Zero
  \return the number of tokens that were on the Queue
 */
int freeTokenQueue(struct TOKEN_QUEUE **head)
{
    struct TOKEN_QUEUE *tmp = NULL;
    int i;
    int ret = 0;

    if (NULL == *head)
    {
        return (0);
    }

    tmp = *head;
    ret = freeTokenQueue(&tmp->next);

    for (i = 0; i < tmp->len; i++)
    {
        if (NULL != tmp->token[i])
        {
            free(tmp->token[i]);
            tmp->token[i] = NULL;
            ret++;
        }
    }

    tmp->len = 0;
    tmp->next = NULL;

    free(*head);

    *head = NULL;
    return (ret);
}

/*!
  \brief This routine reads tokens from a file.

  Will parse tokens out of the file, Blank lines are ignored. If

  \param[in] fd an int file descriptor pointing to a file that we move 
  through and parse the tokens from 
  \param[out] tokenHead a pointer to a pointer that the tokens that are 
  parsed out are stored to. 
  \param[in] delimiter a char that says what the delimiter of the
  tokens are.
  \param[in] tokenLimit an int that says only take up to this many
  tokens from the file, if set to less than 1 then all tokens will
  be taken in.
  \param[out] lineNumber pointer to an integer, will be increased whenever
  a new line character is encountered.
  \param[in] newLineBreaks, if set to 1 we will return  from the routine
  when we encounter a new line character
  \retval -1 file not open
  \retval -99 EOF
  \retval >= 0 number of CSV tokens on line 
 */
int fillTokensFromFile(int fd, struct TOKEN_QUEUE **tokenHead,
		       char delimiter, int tokenLimit, int *lineNumber,
		       int newLineBreaks,char quote)
{

    char *tokenBuff = NULL;
    struct CHARACTER_QUEUE *head = NULL;

    static char readChar[512];
    static int readin = 0;
    static int sc = 0;

    int numTokens = 0;

    static int newLine = 0;

    int size = 0;
    int ret = 0;

    int inQuote = 0;
    int quoteDepth = 0;
    int numQuotes = 0;

    if (fd < 1)
    {
        return (-1);
    }

    /*try to read */
    if (readin < 1 || sc >= readin)
    {
        readin = read(fd, readChar, sizeof(readChar));
        sc = 0;
    }

    /*EOF Test */
    if (readin < 1)
    {
         /*EOF*/ return (-99);
    }

    for (;;)
    {

        if (sc >= readin)
        {
            readin = read(fd, readChar, sizeof(readChar));
            if (readin < 1)
            {
                break;
            }
            sc = 0;
        }

	if(quote && (quote == readChar[sc]))
	  {
	    
	    inQuote = (inQuote + 1) % 2;
	      
	    numQuotes++;
	    if(2 == numQuotes)
	      {
		/*Enqueue Quoted Quote*/
		if(quoteDepth > 0)
		  {
		    /*We Do not upcase quote chars normally*/
		    if(2 == UpcaseTokens)
		    {
			size = enqueueCharacter(&head, toupper(quote));
		    }
		    else
		    {
			/*Do Not Uppercase*/
			size = enqueueCharacter(&head, quote);
		    }
		    numQuotes = 0;
		  }
		else
		  {
		    /*Just in case a quote is next*/
		    numQuotes = 1;
		  }
	      }  

	    if(!inQuote)
	      {
		quoteDepth++;
	      }

	    sc++;
	    continue;
	  }

	numQuotes = 0;

        if (('\n' == readChar[sc]) && (NULL != lineNumber))
        {
            /*increase the line count */
            *lineNumber = (*lineNumber) + 1;
        }

        if (((!inQuote) && (delimiter == readChar[sc])) ||
            '\r' == readChar[sc] || '\n' == readChar[sc])
        {

	    /*Reset Quote Vars*/
	    inQuote = 0;
	    quoteDepth = 0;
	    numQuotes = 0;

            if (newLine)
            {
                /*multiple new line characters */
                sc++;
                continue;
            }

            if (size > 0)
            {
                /*Malloc tokenBuff +1 Copy Character Queue to Buffer */
                tokenBuff = (char *)malloc(sizeof(char) * (size + 1));
                memset(tokenBuff, '\0', size + 1);
                dumpCharQueueToStr(tokenBuff, head);
                enqueueToken(tokenHead, tokenBuff);
                /*Clear Character Queue */
                ret = freeCharacterQueue(&head);
                head = NULL;
                /*printf("TOKEN : %s\n", tokenBuff); */
            }
            else if (delimiter == readChar[sc])
            {
                enqueueToken(tokenHead, "\0");
            }

            if ('\r' == readChar[sc] || '\n' == readChar[sc])
            {
                /*if the token breaker was a new line character 
                   then we mark it so in case multiple new line characters */
                newLine = 1;
            }

            /*Assign tokenBuff pointer to Node (enqueue) */

            size = 0;
            free(tokenBuff);
            tokenBuff = NULL;

            sc++;
            size = 0;
            /*Up the Number of Tokens */
            numTokens++;
            if (tokenLimit > 0)
            {
                if (numTokens >= tokenLimit)
                {
                    return (numTokens);
                }
            }

	    if(newLineBreaks && newLine)
	      {
		return (numTokens);
	      }

            continue;
        }

        /*Enqueue readChar[sc] */
	if(0 != UpcaseTokens)
	{
	    size = enqueueCharacter(&head, toupper(readChar[sc]));
	}
	else
	{
	    size = enqueueCharacter(&head, readChar[sc]);
	}
        newLine = 0;
        sc++;
    }

    if (size > 0)
    {

        /*Malloc tokenBuff +1 Copy Character Queue to Buffer */
        tokenBuff = (char *)malloc(sizeof(char) * (size + 1));
        memset(tokenBuff, '\0', size + 1);
        dumpCharQueueToStr(tokenBuff, head);
        enqueueToken(tokenHead, tokenBuff);
        /*Clear Character Queue */
        ret = freeCharacterQueue(&head);
        head = NULL;
        /*printf("(last) TOKEN : %s\n", tokenBuff); */

        /*printf("[%s]\n",lbuff); */
        free(tokenBuff);
        tokenBuff = NULL;
        numTokens++;
    }

    return (numTokens);
}


int readClientMapFile(struct GENERIC_CLIENT_LIST **head)
{
    int fd = -1;
    struct TOKEN_QUEUE *mytokens = NULL;
    int ret;
    struct GENERIC_CLIENT_LIST *tmp = NULL;

    umask(0);

    fd = open(GENERIC_CLIENTMAP_FILENAME, O_RDONLY);

    if (fd < 0)
    {
        l_error("Cannot open %s for Reading", GENERIC_CLIENTMAP_FILENAME);
        return (-1);
    }

    while (fillTokensFromFile(fd, &mytokens, '\t', 0, NULL, 1,'\0') > -1)
    {
        tmp = newClientMapNode(head);
        setCharField(tmp->code1, 11, getTokenNumber(mytokens, 0));
        setCharField(tmp->code2, 11, getTokenNumber(mytokens, 1));
        setCharField(tmp->client, 8, getTokenNumber(mytokens, 2));

        ret = freeTokenQueue(&mytokens);
    }

    close(fd);

    return (getSizeOfClientMapList(*head));
}

struct GENERIC_CLIENT_LIST *newClientMapNode(struct GENERIC_CLIENT_LIST **head)
{
    struct GENERIC_CLIENT_LIST *tmp = NULL;
    struct GENERIC_CLIENT_LIST *walk = NULL;

    tmp = (struct GENERIC_CLIENT_LIST *)
                        malloc(sizeof(struct GENERIC_CLIENT_LIST));

    memset((char *)tmp, '\0', sizeof(struct GENERIC_CLIENT_LIST));
    setCharField(tmp->code1, 11, "           ");
    setCharField(tmp->code2, 11, "           ");
    setCharField(tmp->client, 8, "        ");

    tmp->next = NULL;

    if (NULL == *head)
    {
        *head = tmp;
    }
    else
    {
        walk = *head;

        while (NULL != walk->next)
        {
            walk = walk->next;
        }

        walk->next = tmp;
    }

    return (tmp);
}

/*!
  \brief get the size of the queue

  \param[in] head pointer to the queue head
  \return the size of the queue
 */
int getSizeOfClientMapList(struct GENERIC_CLIENT_LIST *head)
{

    struct GENERIC_CLIENT_LIST *tmp = NULL;
    int number = 0;

    if (NULL == head)
    {
        /*There is nothing here */
        return (0);
    }

    tmp = head;

    number = 0;

    while (NULL != tmp)
    {
        number++;
        tmp = tmp->next;
    }

    return (number);
}

/*!

 */
int sortClientMapList(struct GENERIC_CLIENT_LIST **head)
{
    static int sortBy = 0;

    struct GENERIC_CLIENT_LIST **list = NULL;
    struct GENERIC_CLIENT_LIST *tmp = NULL;
    int size;
    int i = 0;
    int j;
    int a, b;

    size = getSizeOfClientMapList(*head);

    if (size < 1)
    {
        return (0);
    }

    list = (struct GENERIC_CLIENT_LIST **)
                        malloc(sizeof(struct GENERIC_CLIENT_LIST *)
                               * size);

    /*Plug them all into the list */
    for (i = 0, tmp = *head; i < size && tmp != NULL; i++, tmp = tmp->next)
    {
        list[i] = tmp;
    }

    /*Sort the list */
    for (i = 0; i < size - 1; i++)
    {
        for (j = i + 1; j < size; j++)
        {
	    if(sortBy)
	      {
		b = memcmp(list[i]->code1,list[j]->code1,10);
		a = memcmp(list[i]->client,list[j]->client,7);
	      }
	    else
	      {
		a = memcmp(list[i]->code1,list[j]->code1,10);
		b = memcmp(list[i]->client,list[j]->client,7);
	      }

            if (a > 0)
            {
                /*swap */
                tmp = list[i];
                list[i] = list[j];
                list[j] = tmp;
            }
            else if ((0 == a) && (b > 0))
            {
                /*if Priority is equal then we check alphabetical Order */
                /*swap */
                tmp = list[i];
                list[i] = list[j];
                list[j] = tmp;
            }
        }
    }

    /*We have to snap all the next pointers now */
    list[size - 1]->next = NULL;
    for (i = 0; i < (size - 1); i++)
    {
        list[i]->next = list[i + 1];
    }

    *head = list[0];

    /*Free the temporary list we have made */
    free(list);

    sortBy = (sortBy + 1) % 2;

    return (getSizeOfClientMapList(*head));
}

/*!
 */
struct GENERIC_CLIENT_LIST *getClientMapNodeAt(struct GENERIC_CLIENT_LIST *head,
					       int pos)
{
    int i;
    int max = 0;
    struct GENERIC_CLIENT_LIST *tmp = NULL;

    if (pos < 0)
    {
        return (NULL);
    }

    max = getSizeOfClientMapList(head);

    if (pos >= max)
    {
        return (NULL);
    }

    i = 0;
    tmp = head;

    while ((NULL != tmp) && (i < max))
    {
        if (i >= pos)
        {
            return (tmp);
        }
        i++;
        tmp = tmp->next;
    }

    return (NULL);
}

/*!
 */
struct GENERIC_CLIENT_LIST *getClientMapNodeByName(struct GENERIC_CLIENT_LIST *head,
						    const char *code1, 
						    const char *code2,
						    const char *code3,
						    int *pos)
{
    int i;
    struct GENERIC_CLIENT_LIST *tmp = NULL;

    *pos = getSizeOfClientMapList(head) + 1;

    for (i = 0, tmp = head; tmp != NULL; tmp = tmp->next, i++)
    {
        trimSpaceAndZeroFromEnd(tmp->code1, strlen(tmp->code1));
        trimSpaceAndZeroFromEnd(tmp->code2, strlen(tmp->code2));

        if (NULL != code1 && strcasecmp(code1, tmp->code1) == 0)
        {
	    /*if there is no code2 or if the code 2 matches*/
	    if(NULL == code2 || strcasecmp(code2, tmp->code2) == 0)
	    {
	        *pos = i;
		return (tmp);
	    }
        }

	if(NULL != code3 && strncasecmp(tmp->client,code3,7) == 0)
	{
	    *pos = i;
	    return (tmp);
	}

    }

    return (NULL);
}

int readAcRcListFile(struct ACTION_RESULT_LIST **head,const char *filename)
{
    int fd = -1;
    struct TOKEN_QUEUE *mytokens = NULL;
    int ret;
    struct ACTION_RESULT_LIST *tmp = NULL;

    umask(0);

    fd = open(filename, O_RDONLY);

    if (fd < 0)
    {
        l_error("Cannot open %s for Reading", filename);
        return (-1);
    }

    while (fillTokensFromFile(fd, &mytokens, '\t', 0, NULL, 1,'\0') > -1)
    {
        tmp = newAcRcNode(head);
        setCharField(tmp->AC, 21, getTokenNumber(mytokens, 0));
        setCharField(tmp->RC, 21, getTokenNumber(mytokens, 1));
	setCharField(tmp->Extra, 21, getTokenNumber(mytokens, 2));

        ret = freeTokenQueue(&mytokens);
    }

    close(fd);

    return (getSizeOfAcRcList(*head));
}

struct ACTION_RESULT_LIST *newAcRcNode(struct ACTION_RESULT_LIST **head)
{
    struct ACTION_RESULT_LIST *tmp = NULL;
    struct ACTION_RESULT_LIST *walk = NULL;

    tmp = (struct ACTION_RESULT_LIST *)
                        malloc(sizeof(struct ACTION_RESULT_LIST));

    memset((char *)tmp, '\0', sizeof(struct ACTION_RESULT_LIST));
    setCharField(tmp->AC, 21, "                     ");
    setCharField(tmp->RC, 21, "                     ");
    setCharField(tmp->Extra, 21, "                     ");

    tmp->next = NULL;

    if (NULL == *head)
    {
        *head = tmp;
    }
    else
    {
        walk = *head;

        while (NULL != walk->next)
        {
            walk = walk->next;
        }

        walk->next = tmp;
    }

    return (tmp);
}


/*!
  \brief get the size of the queue

  \param[in] head pointer to the queue head
  \return the size of the queue
 */
int getSizeOfAcRcList(struct ACTION_RESULT_LIST *head)
{

    struct ACTION_RESULT_LIST *tmp = NULL;
    int number = 0;

    if (NULL == head)
    {
        /*There is nothing here */
        return (0);
    }

    tmp = head;

    number = 0;

    while (NULL != tmp)
    {
        number++;
        tmp = tmp->next;
    }

    return (number);
}

struct ACTION_RESULT_LIST *getAcRcNodeAt(struct ACTION_RESULT_LIST *head,
					       int pos)
{
    int i;
    int max = 0;
    struct ACTION_RESULT_LIST *tmp = NULL;

    if (pos < 0)
    {
        return (NULL);
    }

    max = getSizeOfAcRcList(head);

    if (pos >= max)
    {
        return (NULL);
    }

    i = 0;
    tmp = head;

    while ((NULL != tmp) && (i < max))
    {
        if (i >= pos)
        {
            return (tmp);
        }
        i++;
        tmp = tmp->next;
    }

    return (NULL);
}

struct ACTION_RESULT_LIST *getAcRcByName(struct ACTION_RESULT_LIST *head,
					 const char *code1, 
					 const char *code2,
					 int *pos)
{
    int i;
    struct ACTION_RESULT_LIST *tmp = NULL;

    *pos = getSizeOfAcRcList(head) + 1;

    if (NULL == code1)
    {
        return (NULL);
    }

    for (i = 0, tmp = head; tmp != NULL; tmp = tmp->next, i++)
    {
        trimSpaceAndZeroFromEnd(tmp->AC, strlen(tmp->AC));
        trimSpaceAndZeroFromEnd(tmp->RC, strlen(tmp->RC));

        if (strcasecmp(code1, tmp->AC) == 0)
        {
	    /*if there is no code2 or if the code 2 matches*/
	    if(NULL == code2 || strcasecmp(code2, tmp->RC) == 0)
	    {
	        *pos = i;
		return (tmp);
	    }
        }
    }

    return (NULL);
}
